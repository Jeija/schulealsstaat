/**
 * API.js
 * This file handles all client communication with the API and webcam server. It manages encryption
 * for communication with the API server and performs asynchronous HTTP requests (AJAX).
 * This file will be copied to all the client applications that need it by the util/prepare.sh
 * script that is also called by the init.sh script.
 * If you cannot set up your own DHCP server that does the domain name resolution for api.saeu
 * and cam.saeu for you, you will have to edit this file in order to allow for communication
 * with both of the servers. You can either edit this file before calling init.sh or edit this file
 * and launch util/prepare.sh afterwards. 
 */

/** The server address and port for the API server - edit this if you need to! **/
var APISERVER = "api.saeu";
var APIPORT = 1230;

/** The server address and port for the API internet proxy server (SSH tunnel) **/
var PROXYSERVER = "centralbank.eu";
var PROXYPORT = 1230;

/** The server address and port for the Webcam server - edit this if you need to! **/
var WEBCAMSERVER = "cam.saeu";
var WEBCAMPORT = 1233;

/** Ping / Query Timeouts: Abort request if server doesn't answer within given time **/
var TIMEOUT_INTRANET = 1500;
var TIMEOUT_INTERNET = 4000;
var TIMEOUT_QUERY = 5000;
var TIMEOUT_POLLING = 60000;

var APIURL = "http://" + APISERVER + ":" + APIPORT + "/";
var PROXYURL = "http://" + PROXYSERVER + ":" + PROXYPORT + "/";
var WEBCAMURL = "http://" + WEBCAMSERVER + ":" + WEBCAMPORT + "/";

/** Query status codes **/
var SUCCESS_INTRANET = 1;
var SUCCESS_INTERNET = 2;
var ERROR = 3;
var ERROR_UNKNOWN = 4;
var ERROR_SPOOF = 5;
var ERROR_ENCRYPTION = 6;

/** For Firefox OS App - require permission for performing AJAX calls **/
$.ajaxSetup({
	xhr: function() {
		return new window.XMLHttpRequest({ mozSystem : true });
	}
});

/**
 * Encryption utilities
 * RSA: Encryption of the symmetric AES password that is generated by the client.
 *      Only the server has the private key, the public keys are distributed to all clients!
 * AES: Encryption of the actual JSON-stringified payload string.
 */

/**
 * Load RSA Public Key
 * Public key location may vary depending on the specific build details
 * Therefore, search the public key at multiple places, such as www/pubkey.pem,
 * the current directory and the parent directory
 */
var pubkey = new JSEncrypt();
function load_pubkey(url) {
	var xhr = new XMLHttpRequest({ mozSystem : true });
	xhr.open("GET", url, true);
	xhr.onload = function () {
		if (xhr.responseText.indexOf("PUBLIC KEY") > -1) {
			pubkey.setPublicKey(xhr.responseText);
		}
	};
	xhr.send();
}


load_pubkey("/www/pubkey.pem");
load_pubkey("../pubkey.pem");
load_pubkey("pubkey.pem");

function encrypt_passphrase (passphrase) {
	return pubkey.encrypt(passphrase);
}

function randomString(length) {
	var s = "";
	for (var i = 0; i < length; i++)
		s += String.fromCharCode(32 + Math.floor(Math.random() * 94));
	return s;
}

/**
 * AES encryption / decryption utilities
 * Using GibberishAES for OpenSSL compatibility. The server issues calls to OpenSSL for faster
 * encryption / decryption with compiled software.
 */
function encrypt_query(passphrase, query) {
	return GibberishAES.enc(query, passphrase);
}

function decrypt_answer(passphrase, answer) {
	try {
		return {
			value : GibberishAES.dec(answer, passphrase),
			success : true
		};
	} catch (e) {
		console.log("Response decryption failed, error is:");
		console.log(answer);
		return {
			value : "error: (while decrypting) " + answer,
			success : false
		};
	}
}

/**
 * send_query
 * This function takes care of generating a random passphrase, encrypting the payload string
 * as AES and then encrypting the random passphrase with the RSA public key.
 */
function send_query(name, query, cb, polling) {
	// Generate AES passphrase
	var passphrase = randomString(32);
	var passphrase_encrypted = encrypt_passphrase(passphrase);
	var query_encrypted = encrypt_query(passphrase, JSON.stringify(query));

	var post = JSON.stringify({
		passphrase : passphrase_encrypted,
		encrypted : query_encrypted
	});

	function perform_query(URL) {
		$.ajax({
			type : "POST",
			url : URL + "action/" + name,
			data : post,
			timeout : polling ? TIMEOUT_POLLING : TIMEOUT_QUERY,
			success : function (res) {
				var decrypt = decrypt_answer(passphrase, res);
				if (!decrypt.success) {
					cb(decrypt.value, ERROR_ENCRYPTION);
					return;
				}

				var success = URL == APIURL ? SUCCESS_INTRANET : SUCCESS_INTERNET;
				cb(JSON.parse(decrypt.value), success);
			},
			error : function () {
				cb(null, ERROR_UNKNOWN);
			}
		});
	}

	function ping_and_perform(URL, timeout, error_cb) {
		$.ajax({
			type : "GET",
			url : URL + "ping/",
			timeout : timeout,
			success : function (data, text, jqXHR) {
				if (jqXHR.status != 204) {
					cb(null, ERROR_SPOOF);
				} else {
					perform_query(URL);
				}
			},
			error: error_cb
		});
	}

	ping_and_perform(APIURL, TIMEOUT_INTRANET, function () {
		ping_and_perform(PROXYURL, TIMEOUT_INTERNET, function () {
			cb(null, ERROR);
		});
	});
}

/**
 * High-level API action calls
 * action(name, payload, cb)
 *	name: The name of the action to be executed on the server (unencrypted)
 *	payload: Any variable that the server requires as payload for the action (encrypted)
 *	cb: Function that is called when an answer from the server is received, of the form
 *		function (response, flags) with
 *		response: the response variable from the API
 *		flags: SUCCESS_INTRANET, SUCCESS_INTERNET or ERROR: information on wheter the
 *		requests was successful through the intranet / internet proxy or unsuccessful
 *		ERROR_UNKNOWN is parsed if the server responded to the ping request, but not
 *		to the action query
 *		ERROR_SPOOF is thrown if the server responded, but not with the 204 HTTP status
 *		code which may be a sign for spoofing
 *
 * action_poll(name, payload, cb)
 *	same as action(name, payload, cb), but with higher timeout
 *
 * action_cert(name, payload, certname, cb)
 *	name, payload, cb same as action
 *	certname: The filename of the certificate file in the cert/ subdirectory that will also
 *		be sent to the server for authentication (encrypted)
 *
 * action_mastercert(name, payload, certfile_selector, cb)
 *	name, payload, cb same as action
 *	cerfile_selector: the query selector of an html <input type="file">, so that the user
 *		has to manually upload the master certificate file. This will alert if no file
 *		has been selected.
 */
function action(name, payload, cb) {
	send_query(name, { payload : payload }, cb);
}

function action_poll(name, payload, cb) {
	send_query(name, { payload : payload }, cb, true);
}

function action_cert(name, payload, certname, cb) {
	$.get("../cert/" + certname, function (cert) {
		send_query(name, { payload : payload, cert : cert }, cb);
	});
}

function action_mastercert(name, payload, certfile_selector, cb) {
	var file = $(certfile_selector)[0].files[0];
	if (!file) {
		alert("Kein Master-Zertifikat gew√§hlt!");
		return;
	}
	var reader = new FileReader();
	reader.onload = function(e) {
		send_query(name, { payload : payload, cert : reader.result }, cb);
	};
	reader.readAsText(file, "utf-8");
}

/**
 * webcamserv_get
 * Get picture file from webcam server (unencrypted!)
 * picname: The filename of the picture (without .png ending)
 * cb: The function that is called when an answer is received. The first parameter is the
 *	base64-encoded png file.
 */
function webcamserv_get(picname, cb) {
	var url = WEBCAMURL + "get/" + picname;
	$.get("../cert/webcam_cert", function (cert) {
		$.ajax({
			type : "POST",
			url : url,
			success : cb,
			data : cert
		});
	});
}

/**
 * webcamserv_upload
 * Upload a picture file to the webcam server (unencrypted!)
 * picname: The filename of the picture (without .png ending)
 * pictureData: base64-encoded PNG picture data
 * cb: The function that is called when an answer is received. First parameter: Server response,
 *	should be "ok"
 */
function webcamserv_upload(picname, pictureData, cb) {
	$.ajax({
		type:		"POST",
		url:		WEBCAMURL + "upload/",
		data:		JSON.stringify({name : picname, pic : pictureData})
	}).done(cb);
}
